# [PGS] 소수 찾기 Lv.1

- 풀이 날짜: 20230625
- 출처: <https://school.programmers.co.kr/learn/courses/30/lessons/12921>

<br />

## 소수 찾기

### 문제 설명

1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.  
(1은 소수가 아닙니다.)

### 제한사항

- n은 2이상 1000000이하의 자연수입니다.

### 입출력 예

| n   | result |
| --- | ------ |
| 10  | 4      |
| 5   | 3      |

### 입출력 예 설명

입출력 예 #1  
1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

입출력 예 #2  
1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환

<br />

## 공부할 개념

- 에라토스테네스의 체
- 시간복잡도

<br />

## 문제 분석

소수를 찾는 방법에는 여러가지 방법이 있다. 단순하게 `완전탐색`으로 2부터 n까지 하나하나 전부 n과 나눠보면서 n과 나누어 떨어진다면 소수가 아닌 것이고 나누어 떨어지지 않는다면 소수가 되는 방법을 사용하여 임시 리스트에 담는 방법이다. 이 경우에는 시간 복잡도가 $O(N)$으로 주어진 n의 크기가 클 수록 점점 느려지게 된다.

그렇다면 조금 더 빠른 방법을 찾아야한다. 이 방법은 자기 자신의 제곱근까지만 확인하면 모든 수를 비교하는 것보다 더 빠르고 효율적일 것이다. 이 경우에는 시간 복잡도가 $O(\sqrt N)$이 되어 완전탐색했던 첫 번째 풀이보다는 더 효율적이게 된다.

하지만 나는 이전에 소수를 판별하는 방법에는 `에라토스테네스의 체`를 사용하는 것이 가장 효율적이라는 것을 **[멀티잇] 코딩테스트 러닝클래스(Python) 5월반** 강의에서 들었던 기억이 났다. 따라서 이 기억에 따라 에라토스테네스의 체를 사용하려 했지만 생각보다 알고리즘을 짜는데 어려움을 겪어 다른 블로그의 글을 참고했다.

<br />

## 나의 문제 풀이 코드

```python
def solution(n):
    temp = [False, False,] + [True] * (n - 1)
    prime = 0

    for i in range(2, n + 1):
        if temp[i]:
            prime += 1
            for j in range(2 * i, n + 1, i):
                temp[j] = False

    return prime
```

참고1: <https://velog.io/@seulki971227/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Lv.1-%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0-Python>  
참고2: <https://codingpractices.tistory.com/entry/Python-%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98>

참고한 블로그의 글에서 어떻게 알고리즘을 만들었는지 확인했다. 일단 temp 리스트에 각 인덱스별로 Boolen 값을 넣고 입력된 n - 1 까지의 인덱스를 가진 리스트를 만들어서 에라토스테네스의 체를 구현하는 것이 기본 골자인 것 같다. 0과 1은 소수가 아니니까 인데스 0과 1은 처음부터 False로 만들어둬야하는 점을 잊으면 안된다. 이렇게 소수가 아닌 경우를 전부 False로 만들어주면서 temp 리스트의 값이 True일 때 prime 변수에 1을 더하여 메모리를 조금 쓰더라도 따로 len()로 추가적인 리스트의 길이를 계산하지 않도록 했다. 이 문제는 어떤 소수가 있는지 확인하는 문제가 아니라 1부터 n까지의 숫자 사이에 소수가 몇 개 있는지 확인하는 것이니 그에 맞게 내 방식대로 조금 변형해봤다.

<br />

## 다른 사람의 코드

```python
def solution(n):
    num=set(range(2,n+1))

    for i in range(2,int(n**0.5)+1):
        if i in num:
            num-=set(range(2*i,n+1,i))
    return len(num)
```

에라토스테네스의 체를 set 자료형을 통해 중복을 없게하고 나머지는 내가 참고했던 알고리즘과 비슷하게 처리한 것 같다.
