# [PGS] 시저 암호 Lv.1

- 풀이 날짜: 20230630
- 출처: <https://school.programmers.co.kr/learn/courses/30/lessons/12926>

<br />

## 시저 암호

### 문제 설명

어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 "AB"는 1만큼 밀면 "BC"가 되고, 3만큼 밀면 "DE"가 됩니다. "z"는 1만큼 밀면 "a"가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

### 제한사항

- 공백은 아무리 밀어도 공백입니다.
- s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.
- s의 길이는 8000이하입니다.
- n은 1 이상, 25이하인 자연수입니다.

### 입출력 예

| s       | n   | result  |
| ------- | --- | ------- |
| "AB"    | 1   | "BC"    |
| "z"     | 1   | "a"     |
| "a B z" | 4   | "e F d" |

<br />

## 공부할 개념

- 문자열 조작
- 리스트 조작

<br />

## 문제 분석

보자마자 유니코드 관련된 문제가 아닐까 생각했다. 그래서 파이썬에서 문자의 유니코드를 확인할 수 있는 `ord()` 함수를 확인했고 유니코드의 문자를 확인할 수 있는 `chr()` 함수를 확인했다. 그것까지는 좋았으나 아무리 생각해도 **Z 혹은 z**을 밀었을 때 어떻게 a, b ... 이런식으로 밀어낼지 알고리즘을 생각해내지 못했다. 예전에는 시저암호를 아주 쉽게 했는데 너무 알고리즘 공부를 등한시 한 것 같다.

아무튼 이런 이유로 모든 키보드에 있는 영어문자를 순서대로 치고 `sorted()` 함수를 사용하여 `a ~ z`, `A ~ Z`의 리스트를 만들고 거기에서 밀어낸 문자를 인덱싱하여 가져오는 것으로 알고리즘을 생각했다. 이 경우에는 다른 방법보다 좀 더 시간 복잡도가 늘어날 것으로 생각된다.

<br />

## 나의 문제 풀이 코드

```python
def solution(s, n):
    down_alpha = sorted("qwertyuiopasdfghjklzxcvbnm")
    up_alpha = sorted("QWERTYUIOPASDFGHJKLZXCVBNM")
    temp_str = ""

    for _ in s:
        if _ == " ":
            temp_str += " "
            continue
        if _.isupper():
            temp_str += up_alpha[(up_alpha.index(_) + n) % len(up_alpha)]
        else:
            temp_str += down_alpha[(down_alpha.index(_) + n) % len(down_alpha)]
    return temp_str
```

문제 분석에도 적어놨지만 `down_alpha` 와 `up_alpha`에 모든 대소문자를 적어놓고 `sorted()`함수를 사용하여 정렬했다. 그리고 문자열 s에서 문자를 하나씩 추출한 뒤 그 문자가 띄워쓰기라면 그대로 띄워쓰기가 나와야하기에 `continue`를 사용하여 추출한 문자가 대문자인지 소문자인지 확인하는 알고리즘을 실행하지 않는다. 그러나 추출한 문자가 띄워쓰기가 아니라면 대문자인지 소문자인지 `isupper()` 함수를 사용하여 확인한다. 그 이후 임시 변수인 temp_str에 그 문자가 몇 번째 인덱스인지 `index()` 로 확인하고 n만큼 더한 값을 알파벳 리스트에서 가져오려고 했다. 그러나 문제 분석에서 말했듯이 z 혹은 Z일 경우 리스트가 넘어가기에 알파벳의 갯수(up_alpha의 길이 = 26)로 나눈 나머지를 값을 순서로 문자를 가져와서 문자열 덧셈으로 하나의 문자열로 만들었다.

<br />

## 다른 사람의 코드

```python
def solution(s, n):
    answer = ''
    for i in s:
        if i:
            if i >= 'A' and i <= 'Z':
                answer += chr((ord(i) - ord('A') + n) % 26 + ord('A'))
            elif i >= 'a' and i <= 'z':
                answer += chr((ord(i) - ord('a') + n) % 26 + ord('a'))
            else : answer += ' '
    return answer
```

다른 코드도 많았지만 이 코드가 끌렸다고 해야하나.. 파이썬에서는 문자도 부등호를 사용할 수 있다는 사실이 신기해서 이 코드를 가져왔다. 기본 골자는 나와 크게 다르지는 않은 것 같으나 나는 변수를 따로 사용하여 `a ~ z`, `A ~ Z`의 리스트를 생성한 이후에 했지만 문제 분석에서 말했듯이 유니코드를 사용하는 `ord()`와 `chr()` 함수를 사용할 수 있을 것 같다고 했는데 그 예상에 맞는 코드를 찾은 것이다. 대부분의 다른 코드들이 이런 느낌으로 풀어져있어서 내가 아주 잘못 풀은건 아니라고 생각했다.
