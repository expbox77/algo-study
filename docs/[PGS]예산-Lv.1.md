# [PGS] 예산 Lv.1

- 풀이 날짜: 20230707
- 출처: <https://school.programmers.co.kr/learn/courses/30/lessons/12982>
- 3시간 초과

<br />

## 예산

### 문제 설명

S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
- d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
- budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

### 입출력 예

| d           | budget | result |
| ----------- | ------ | ------ |
| [1,3,2,5,4] | 9      | 3      |
| [2,2,3,3]   | 10     | 4      |

### 입출력 예 설명

입출력 예 #1  
각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

- 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
- 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
- 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
- 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.

3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

입출력 예 #2  
모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.

<br />

## 공부할 개념

-

<br />

## 문제 분석

문제를 봤을 때 조합으로 풀어야하나 싶었다.(이전에 풀었던 [소수 만들기](/code/%5BPGS%5D%EC%86%8C%EC%88%98%20%EB%A7%8C%EB%93%A4%EA%B8%B0-Lv.1.py)가 떠올랐다.) 하지만 풀이 과정과 시간복잡도를 생각해봤을 때 이 풀이 방법은 맞지 않아보이는 것 같아 조금 더 고민을 해보는 것으로 했다. 고민을 해봤는데 DFS, BFS 알고리즘에 대해서 공부도 해봤지만 아무리 생각해도 어떻게 푸는지 감이 잡히지 않아 힌트를 좀 보기로 했다.

다른 사람의 코드를 보기 전 풀이 과정을 좀 봤는데 모든 풀이 과정에서 `sort()` 함수를 사용하여 주어진 `d` 리스트를 정렬하는 과정을 거쳤다. 작은 수에서 더해가거나 모든 수를 더한 뒤 가장 큰 원소를 빼는 방법을 사용하는 것으로 알고리즘을 만들었다. 풀이를 보고 난 후에는 그리 어렵지 않게 알고리즘을 풀었으면 좋았겠으나 그러지 못했다. 처음 봤던 풀이가 모든 수를 더한 후 가장 큰 원소를 빼는 알고리즘이어서 나는 가장 작은 원소를 더하는 알고리즘을 만드는 것으로 생각했으나 구현에 실패하면서 최대 시간인 3시간이 지남에 따라 풀이를 확인하게 되었다.

<br />

## 다른 사람의 코드 1

```python
def solution(d, budget):
    d.sort()
    while budget < sum(d):
        d.pop()
    return len(d)
```

가장 심플한 방법이라고 생각한다. 먼저 `sort()`를 사용하여 오름차순으로 정렬한다. 그 후 **while 문을 사용해서 `d` 리스트 원소들의 합이 budget을 넘는다면** `d` 리스트의 마지막(가장 큰) 원소를 뺀다. 그 후 `d` 리스트의 길이를 리턴한다.

<br />

## 다른 사람의 코드 2

```python
def solution(d, budget):
    d.sort()
    cnt = 0
    for i in d :
        budget -= i
        if budget < 0 :
               break
        cnt += 1
    return cnt
```

이 풀이는 `budget`에서 `d` 리스트에서 가장 작은 값을 조금씩 빼면서 `budget` 값이 0보다 작아지지 않게 하는 알고리즘으로 보인다.

<br />

## 다른 사람의 코드 3

```python
def solution(d, budget):
    sd = sorted(d)
    answer = 0
    sum = 0
    for i in sd :
        sum += i
        if sum > budget :
            break
        answer += 1
    return answer
```

사실 내가 하려던 알고리즘이 이런 느낌이 아니었을까 생각한다. sum 변수를 지정하고 거기에 `d` 리스트 원소를 작은것부터 더해나가면서 `budget`과 비교하는 것이다.

메모리가 10메가인 것을 너무 의식해서 최대한 변수를 사용하지 않으려다보니 변수를 사용하려는 생각을 계속 못하는 것 같다. Lv.1의 문제에서는 사실 메모리를 엄청 사용해도 10메가의 메모리를 전부 사용하는 것은 불가능에 가까운데 앞으로는 시간복잡도가 늘어난다고해도 일단 풀어본다는 관점에서 변수도 많이 써보는 등 적극적으로 문제를 풀어야겠다고 생각한다.
