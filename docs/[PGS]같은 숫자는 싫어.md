# [PGS] 같은 숫자는 싫어 Lv.1

- 풀이 날짜: 20230614
- 출처: <https://school.programmers.co.kr/learn/courses/30/lessons/12906>

<br />

## 같은 숫자는 싫어

### 문제 설명

배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,

- arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
- arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.

배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

### 제한사항

- 배열 arr의 크기 : 1,000,000 이하의 자연수
- 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

### 입출력 예

| arr                   | answer       |
| --------------------- | ------------ |
| [1, 1, 3, 3, 0, 1, 1] | [1, 3, 0, 1] |
| [4, 4, 4, 3, 3]       | [4, 3]       |

### 입출력 예 설명

입출력 예 #1,2  
문제의 예시와 같습니다.

<br />

## 공부할 개념

- 리스트 다루기

<br />

## 문제 분석

중복 제거를 어떻게 할지 고민하다보니 내가 모르는 파이썬의 중복 제거 방법을 알고자 검색했다. 그랬더니 한 [블로그의 글](https://blockdmask.tistory.com/543)이 나와 읽게 되었다. 이 글은 중복 제거를 파이썬 기본 패키지를 이용하는 것이 아닌 for 문으로 임시 변수를 만들어 거기에 원본 데이터의 값을 넣어 중복을 제거하는 방법을 제시했다. 생각해보니 나는 temp 변수를 최대한 피하면서 원본 데이터에서 뭔가를 바꾸는 것을 굉장히 선호했다는 생각이 들었다.

그래서 이번에는 임시 변수를 사용해서 해결하려고 한다. 임시 변수를 만들어 가장 뒤에 있는 원소와 원본 리스트의 원소의 값을 비교하면서 그 값이 같다면 추가하지 않고 다르다면 추가하는 알고리즘이면 충분히 잘 작동할 것이다.

<br />

## 나의 문제 풀이 코드

```python
def solution(arr):
    temp_list = [arr[0], ]
    for _ in arr:
        if _ != temp_list[-1]:
            temp_list.append(_)
    return temp_list
```

처음에는 임시 리스트의 원소가 아무것도 없다보니 `temp_list[-1]`에서의 오류가 계속 났다. 그래서 어짜피 원본 리스트의 제일 첫번째 원소는 아무것도 없는 임시 리스트에도 없는 것이 자명하기 때문에 아예 임시 리스트에 원본 리스트의 첫 번째 원소를 넣어주고 시작했다. 그랬더니 잘 작동하는 것을 확인했다. 원본 리스트에서 원소를 하나씩 가져오고 그 값과 임시 리스트의 마지막 원소를 비교하여 같다면 넘어가고 같지 않다면 임시 리스트의 마지막에 그 원소를 추가한다.

<br />

## 다른 사람의 코드

```python
def no_continuous(s):
    # 함수를 완성하세요
    a = []
    for i in s:
        if a[-1:] == [i]: continue
        a.append(i)
    return a
```

내 코드와 근본적으로는 다르지않다. 다만 나와 다르게 슬라이싱을 좀 더 적절하게 사용하여 임시 리스트의 원소가 없을 때도 오류가 생기지 않게끔 잘 처리한 것 같다.
